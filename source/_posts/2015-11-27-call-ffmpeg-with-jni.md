title: Android多媒体之二：jni调用ffmpeg命令
date: 2015-11-27 15:38:42
categories:
- Android
- FFmpeg
tags:
- Android
- FFmpeg
- jni
---
FFmpeg除了提供了强大的编解码库之外，也提供了一些命令行工具ffmpeg、ffplay、ffprobe、ffserver。如果对lib不太熟悉，而要实现的功能也比较简单，可以直接调用ffmpeg的命令实现。
<!--more-->

## 准备
以ffmpeg2.5为例，准备ffmpeg2.5源码，以及编译好的lib和include。编译方法见:

[Android多媒体之一：编译ffmpeg](/2015/11/26/android-multimedia-compile-ffmpeg/)

准备ndk，并配好环境变量；准备Android studio。

## ffmpeg简要分析

首先看下ffmpeg各个库的作用，这样简单的函数根据函数名就能猜到作用是什么：

	libavcodec encoding/decoding library
	libavfilter graph-based frame editing library
	libavformat I/O and muxing/demuxing library
	libavdevice special devices muxing/demuxing library
	libavutil common utility library
	libswresample audio resampling, format conversion and mixing
	libpostproc post processing library
	libswscale color conversion and scaling library

接下来分析ffmpeg.c的main函数源码，因为我们调用命令就是执行main函数：
![](http://7xoljq.com1.z0.glb.clouddn.com/15-11-30/6808969.jpg)


main函数主要调用了以下函数：

register_exit(ffmpeg_cleanup)：注册退出时清理函数；

av_log_set_flags和parse_loglevel：跟log相关的，不管；

avcodec_register_all ：注册编码解码器；

avdevice_register_all：注册特殊设备的封装库；

avfilter_register_all：注册帧编辑库；

av_register_all：注册所有封装和分离器；

avformat_network_init：初始化网络组建，ffmpeg是支持拉取远程视频流的；

show_banner：打印输出FFmpeg版本信息（编译时间，编译选项，类库信息等）；

term_init：初始化对终端命令的响应；

ffmpeg_parse_options：解析输入的参数；

transcode：转码过程；

exit_progam：退出和清理。

## 编写代码

### 编写jni代码
既然执行命令的入口是在main函数，那我们在java代码中定义一个native方法，并在相应的c代码中调用main函数不就可以了吗。
新建一个android工程，我这里用包名org.mqstack.ffmpegjni，新建FFmpegJni.java，写入：

	public class FFmpegJni {

		static {
	        System.loadLibrary("avutil");
			System.loadLibrary("swresample");
			System.loadLibrary("avcodec");
			System.loadLibrary("avformat");
			System.loadLibrary("swscale");
			System.loadLibrary("avfilter");
			System.loadLibrary("avdevice");
			System.loadLibrary("ffmpegjni");
		}

		public int ffmpegRunCommand(String command) {
			if (command.isEmpty()) {
				return 1;
			}
	        String[] args = command.split(" ");
	        for (int i = 0; i < args.length; i++) {
	            Log.d("ffmpeg-jni", args[i]);
			}
			return run(args.length, args);
		}

		public native int run(int argc, String[] args);
	}


使用javah生成头文件：

	javah -classpath path_to_FFmpegJni -jni class_name

生成的代码类似如下：

	/* DO NOT EDIT THIS FILE - it is machine generated */
	#include <jni.h>
	/* Header for class org_mqstack_ffmpegjni_FFmpegJni */

	#ifndef _Included_org_mqstack_ffmpegjni_FFmpegJni
	#define _Included_org_mqstack_ffmpegjni_FFmpegJni
	#ifdef __cplusplus
	extern "C" {
	#endif
	/*
	 * Class:     org_mqstack_ffmpegjni_FFmpegJni
	 * Method:    run
	 * Signature: (I[Ljava/lang/String;)I
	 */
	JNIEXPORT jint JNICALL Java_org_mqstack_ffmpegjni_FFmpegJni_run
	        (JNIEnv *, jobject, jint, jobjectArray);

	#ifdef __cplusplus
	}
	#endif
	#endif

编写相应的c文件FFmpegJni.c，代码很好理解：
	#include "logjni.h"
	#include "FFmpegJni.h"

	#include <stdlib.h>
	#include <stdbool.h>

	int main(int argc, char **argv);

	JNIEXPORT jint JNICALL Java_org_mqstack_ffmpegjni_FFmpegJni_run(JNIEnv *env, jobject obj, jint argc, jobjectArray args) {
		int i = 0;
	    char **argv = NULL;
		jstring *strr = NULL;

	    if (args != NULL) {
	        argv = (char **) malloc(sizeof(char *) * argc);
			strr = (jstring *) malloc(sizeof(jstring) * argc);

	        for (i = 0; i < argc; ++i) {
	            strr[i] = (jstring)(*env)->GetObjectArrayElement(env, args, i);
				argv[i] = (char *)(*env)->GetStringUTFChars(env, strr[i], 0);
	            LOGD("args: %s", argv[i]);
			}
	    }

	    LOGD("Run ffmpeg");
	    int result = main(argc, argv);
		LOGD("ffmpeg result %d", result);

	    for (i = 0; i < argc; ++i) {
	        (*env)->ReleaseStringUTFChars(env, strr[i], argv[i]);
		}
	    free(argv);
		free(strr);

	    return result;
	}

其中logjni.h是我写的一个android打印方法的封装：
	#ifndef LOGJAM_H
	#define LOGJAM_H

	#include <android/log.h>

	#define LOGTAG "FFmpegJni"

	#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOGTAG, __VA_ARGS__)
	#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG  , LOGTAG, __VA_ARGS__)
	#define LOGI(...) __android_log_print(ANDROID_LOG_INFO   , LOGTAG, __VA_ARGS__)
	#define LOGW(...) __android_log_print(ANDROID_LOG_WARN   , LOGTAG, __VA_ARGS__)
	#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR  , LOGTAG, __VA_ARGS__)

	#endif

将上述文件放到工程的jni目录下，既然要执行ffmpeg.c中的函数，显然ffmpeg.c和ffmpeg.h要拷贝到jni目录下。
再看ffmpeg.c代码，里面include了一堆lib，
	#include "libavformat/avformat.h"
	#include "libavdevice/avdevice.h"
	#include "libswresample/swresample.h"
	#include "libavutil/opt.h"
	#include "libavutil/channel_layout.h"
	#include "libavutil/parseutils.h"
	#include "libavutil/samplefmt.h"
	#include "libavutil/fifo.h"
	#include "libavutil/intreadwrite.h"
	#include "libavutil/dict.h"
	#include "libavutil/mathematics.h"
	#include "libavutil/pixdesc.h"
	#include "libavutil/avstring.h"
	#include "libavutil/libm.h"
	#include "libavutil/imgutils.h"
	#include "libavutil/timestamp.h"
	#include "libavutil/bprint.h"
	#include "libavutil/time.h"
	#include "libavutil/threadmessage.h"
	#include "libavformat/os_support.h"

那显然要将之前编译成的include文件夹放在jni目录下，同时在jni目录下新建prebuild/armeabi文件夹，将之前编译的so拷贝进去。

ffmpeg.c中还用到了不是lib中的c

	cmdutils.c ffmpeg_opt.c ffmpeg_filter.c

还有这些代码中include到的h

	cmdutils.h cmdutils_common_opts.h config.h

将这些文件全部拷贝到jni文件夹。

### 修改main函数
由于在终端中输入命令，ffmpeg可以新建进程、执行命令然后在销毁进程。但在java程序中，我们不想让命令执行完就直接退出。于是main函数中要做些改动：

将所有的异常的exit_progam，都改为return；

将打印lig的方法都改为android的打印；

将正常的exit\_program改为ffmpeg_cleanup(0)。


	/* parse options and open all input/output files */
	ret = ffmpeg_parse_options(argc, argv);
	    if (ret < 0) {
	        LOGD("ffmpeg_parse_options err");
	        return 1;
	}

	if (nb_output_files <= 0 && nb_input_files == 0) {
	        show_usage();
	LOGD("Use -h to get full help or, even better, run 'man %s'\n", program_name);
	        return 1;
	}

	/* file converter / grab */
	if (nb_output_files <= 0) {
	        LOGD("At least one output file must be specified\n");
	        return 1;
	}

	//     if (nb_input_files == 0) {
	//         av_log(NULL, AV_LOG_FATAL, "At least one input file must be specified\n");
	//         exit_program(1);
	//     }

	current_time = ti = getutime();
	    if (transcode() < 0) {
	        LOGD("failed~~");
	        return 1;
	}
	    ti = getutime() - ti;
	    if (do_benchmark) {
	        LOGD("bench: utime=%0.3fs\n", ti / 1000000.0);
	}
	    LOGD("%"PRIu64" frames successfully decoded, %"PRIu64" decoding errors\n",
	decode_error_stat[0], decode_error_stat[1]);
	    if ((decode_error_stat[0] + decode_error_stat[1]) * max_error_rate < decode_error_stat[1])
	        LOGD("log error");

	ffmpeg_cleanup(0);
	    return main_return_code;


还要在ffmpeg_cleanup函数的最后加上几行，在进程不销毁的情况下，将一些变量初始化。

	nb_filtergraphs = 0;
	nb_output_files = 0;
	nb_output_streams = 0;
	nb_input_files = 0;
	nb_input_streams = 0;

### 编写mk文件

不多说了，参考[官方说明](http://developer.android.com/ndk/guides/android_mk.html)。

	LOCAL_PATH:= $(call my-dir)

	include $(CLEAR_VARS)
	LOCAL_MODULE:= avcodec-prebuilt-armeabi
	LOCAL_SRC_FILES:= prebuilt/armeabi/libavcodec.so
	include $(PREBUILT_SHARED_LIBRARY)

	include $(CLEAR_VARS)
	LOCAL_MODULE:= avdevice-prebuilt-armeabi
	LOCAL_SRC_FILES:= prebuilt/armeabi/libavdevice.so
	include $(PREBUILT_SHARED_LIBRARY)

	include $(CLEAR_VARS)
	LOCAL_MODULE:= avfilter-prebuilt-armeabi
	LOCAL_SRC_FILES:= prebuilt/armeabi/libavfilter.so
	include $(PREBUILT_SHARED_LIBRARY)

	include $(CLEAR_VARS)
	LOCAL_MODULE:= avformat-prebuilt-armeabi
	LOCAL_SRC_FILES:= prebuilt/armeabi/libavformat.so
	include $(PREBUILT_SHARED_LIBRARY)

	include $(CLEAR_VARS)
	LOCAL_MODULE :=  avutil-prebuilt-armeabi
	LOCAL_SRC_FILES := prebuilt/armeabi/libavutil.so
	include $(PREBUILT_SHARED_LIBRARY)

	include $(CLEAR_VARS)
	LOCAL_MODULE := swresample-prebuilt-armeabi
	LOCAL_SRC_FILES := prebuilt/armeabi/libswresample.so
	include $(PREBUILT_SHARED_LIBRARY)

	include $(CLEAR_VARS)
	LOCAL_MODULE := swscale-prebuilt-armeabi
	LOCAL_SRC_FILES := prebuilt/armeabi/libswscale.so
	include $(PREBUILT_SHARED_LIBRARY)

	include $(CLEAR_VARS)

	LOCAL_MODULE := libffmpegjni

	LOCAL_ARM_MODE := arm

	LOCAL_SRC_FILES := FFmpegJni.c \
	                   ffmpeg.c \
	                   cmdutils.c \
	                   ffmpeg_opt.c \
	                   ffmpeg_filter.c

	LOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog -lz

	LOCAL_SHARED_LIBRARIES:= avcodec-prebuilt-armeabi \
	                         avdevice-prebuilt-armeabi \
	                         avfilter-prebuilt-armeabi \
	                         avformat-prebuilt-armeabi \
	                         avutil-prebuilt-armeabi \
	                         swresample-prebuilt-armeabi \
	                         swscale-prebuilt-armeabi

	LOCAL_C_INCLUDES += -L$(SYSROOT)/usr/include
	LOCAL_C_INCLUDES += $(LOCAL_PATH)/include

	LOCAL_CFLAGS := -DUSE_ARM_CONFIG

	include $(BUILD_SHARED_LIBRARY)

## ndk-build

接下来就cd到jni目录，然后ndk-build编译。编译过程中，应该会提示缺少一些头文件如下，从ffmpeg工程中拷贝过来就可以了。

	libavutil/libm.h
	libavformat/os_support.h
	libavformat/ffm.h network.h url.h
	compat/va_copy.h
	libavresample/avresample.h version.h
	libpostproc/postprocess.h version.h

编译结果在libs/armeabi目录下，如下所示

![](http://7xoljq.com1.z0.glb.clouddn.com/15-11-30/22794511.jpg)

将这些so拷贝到android工程的jniLibs或其他依赖的目录中，跑一条命令试试看吧。

本文中代码可在我的github中看到。

https://github.com/mqstack/FFmpegJni

## 更多

[Android多媒体之一：编译ffmpeg](/2015/11/26/android-multimedia-compile-ffmpeg/)
[Android多媒体之三：编译并使用x264库](/2015/12/03/build-x264-with-ndk/)

## 参考

http://blog.csdn.net/leixiaohua1020/article/details/39760711

https://github.com/dxjia/ffmpeg-jni-sample

https://github.com/andynicholson/android-ffmpeg-x264
